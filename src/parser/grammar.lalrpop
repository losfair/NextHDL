use crate::ast;
use crate::parser::error::LocalParseError;
use lalrpop_util::ParseError;
use crate::parser::grammar_helper as helper;

grammar;

extern {
  type Error = LocalParseError;
}

pub ModuleDef: ast::ModuleDef = {
  <items:ModuleItem*> => ast::ModuleDef { items },
};

ModuleItem: ast::ModuleItem = {
  <x:FnDef> => ast::ModuleItem::Fn(x),
  "extern" "signal" <x:GenericDef> ";" => ast::ModuleItem::ExternSignal(x),
};

FnDef: ast::FnDef = {
  "fn" <name:Identifier> <meta:FnMeta> <specializations:MaybeFnSpecializations> => ast::FnDef { name, meta, specializations }
};

GenericDef: ast::GenericDef = {
  <name:Identifier> <ty:(":" <Type>)?> <init_value:("=" <Expr>)?> => ast::GenericDef { name, ty, init_value },
};

MaybeFnSpecializations: Vec<ast::FnSpecialization> = {
  <w:FnSpecializationWhere*> <d:FnSpecializationDefault> => {
    let mut w = w;
    w.push(d);
    w
  },
  <body:FnBody> => vec![ast::FnSpecialization { where_expr: None, body }],
};

FnSpecializationWhere: ast::FnSpecialization = {
  "where" <e:ExprTypeLevel> <body:FnBody> => ast::FnSpecialization { where_expr: Some(e), body },
};

FnSpecializationDefault: ast::FnSpecialization = {
  "default" <body:FnBody> => ast::FnSpecialization { where_expr: None, body },
};

FnBody: ast::FnBody = {
  "{" <body:Body> "}" => ast::FnBody { body },
};

Type: ast::Type = {
  "fn" <meta:FnMeta> => ast::Type { v: ast::TypeV::Fn { meta } },
  <name:Identifier> <tyargs:ActualTyArgList?> => ast::Type { v: ast::TypeV::Named {
    name,
    tyargs: tyargs.unwrap_or_else(|| vec![]),
  } },
};

FnMeta: ast::FnMeta = {
  <tyargs:FnTyArgList?> <args:FnArgList> <ret:FnRet?> => ast::FnMeta {
    tyargs: tyargs.unwrap_or_else(|| vec![]),
    args,
    ret,
  },
};

FnRet: Box<ast::Type> = {
  "->" <ty:Type> => Box::new(ty),
};

FnTyArgList: Vec<ast::FnTyArg> = {
  "<" <list:Comma<FnTyArg>> ">" => list,
};

FnTyArg: ast::FnTyArg = {
  <name:Identifier> ":" <kind:Type> => ast::FnTyArg { name, kind },
};

FnArgList: Vec<ast::FnArg> = {
  "(" <list:Comma<FnArg>> ")" => list,
};

FnArg: ast::FnArg = {
  <name:Identifier> ":" <ty:Type> => ast::FnArg { name, ty },
};

ActualTyArgList: Vec<ast::Expr> = {
  "<" <list:Comma<ExprTypeLevel>> ">" => list,
};

ActualArgList<I>: Vec<ast::Expr> = {
  "(" <list:Comma<I>> ")" => list,
};

Block: ast::Block = {
  "{" <args:FnArgList> "in" <body:Body> "}" => ast::Block { args, body },
  "{" <body:Body> "}" => ast::Block { args: vec![], body },
};

Body: Vec<ast::Stmt> = {
  Stmt*
};

Stmt: ast::Stmt = {
  <v:StmtV> => ast::Stmt { v },
};

StmtV: ast::StmtV = {
  "let" <def:GenericDef> ";" => ast::StmtV::Let { def },
  "signal" <def:GenericDef> ";" => ast::StmtV::Signal { def },
  "if" <e:Expr> "{" <if_body:Body> "}" => ast::StmtV::IfElse { condition: e, if_body, else_body: None },
  "if" <e:Expr> "{" <if_body:Body> "}" "else" "{" <else_body:Body> "}" => ast::StmtV::IfElse {
    condition: e,
    if_body,
    else_body: Some(else_body),
  },
  <left:Identifier> "=" <right:Expr> => ast::StmtV::Assign { left, right },
  <e:Expr> ";" => ast::StmtV::Expr { e },
  <e:Expr> <b:Block> ";"? => {
    let mut e = e;
    let b = ast::Expr { v: ast::ExprV::Block(Box::new(b)) };
    if let ast::ExprV::Call { ref mut args, .. } = e.v {
      args.push(b);
      ast::StmtV::Expr { e }
    } else {
      ast::StmtV::Expr {
        e: ast::Expr {
          v: ast::ExprV::Call {
            base: Box::new(e),
            args: vec![b],
          },
        },
      }
    }
  }
}

ExprBase<I>: ast::Expr = {
  <v:ExprBaseV<I>> => ast::Expr { v }
};

ExprBaseV<I>: ast::ExprV = {
  <l:Literal> => ast::ExprV::Lit(l),
  <id:Identifier> => ast::ExprV::Ident(id),
  <base:I> "." <id:Identifier> => ast::ExprV::Dot { base: Box::new(base), id },
  <base:I> <tyargs:ActualTyArgList> => ast::ExprV::Specialize { base: Box::new(base), tyargs },
  <base:I> <args:ActualArgList<I>> => {
    ast::ExprV::Call { base: Box::new(base), args }
  },
  <b:Block> => ast::ExprV::Block(Box::new(b)),
};

ExprTypeLevel: ast::Expr = {
  ExprBase<ExprTypeLevel>,
};

Expr: ast::Expr = {
  ExprBase<Expr>,
};

Literal: ast::Literal = {
  <s:r"[0-9]+"> =>? s.parse().map(|x| ast::Literal { v: ast::LiteralV::Uint(x) }).map_err(|_| ParseError::User {
    error: LocalParseError::InvalidLiteral,
  }),
  <s:r"0x[0-9a-fA-F]+"> =>? helper::parse_radix_prefixed_str(s, "0x", 16),
  <s:r"0o[0-9a-fA-F]+"> =>? helper::parse_radix_prefixed_str(s, "0o", 8),
  <s:r"0b[0-9a-fA-F]+"> =>? helper::parse_radix_prefixed_str(s, "0b", 2),
};

Identifier: ast::Identifier = {
  <s:r"[a-zA-Z_][0-9a-zA-Z_]*"> => ast::Identifier(s.to_string()),
};

Comma<T>: Vec<T> = { 
  <v:(<T> ",")*> <e:T?> => match e {
    None => v,
    Some(e) => {
      let mut v = v;
      v.push(e);
      v
    }
  }
};