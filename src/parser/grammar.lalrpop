use crate::ast;
use crate::parser::error::LocalParseError;
use lalrpop_util::ParseError;
use crate::parser::grammar_helper as helper;

grammar;

extern {
  type Error = LocalParseError;
}

pub ModuleDef: ast::ModuleDef = {
  <items:ModuleItem*> => ast::ModuleDef { items },
};

ModuleItem: ast::ModuleItem = {
  <x:FnDef> => ast::ModuleItem::Fn(x),
  Token<"extern"> Token<"signal"> <x:GenericDef> Token<";"> => ast::ModuleItem::ExternSignal(x),
  Token<"import"> <path:StringLit> Token<"as"> <as_name:Identifier> Token<";"> => ast::ModuleItem::Import(ast::ImportItem { path, as_name }),
};

FnDef: ast::FnDef = {
  Token<"fn"> <name:Identifier> <meta:FnMeta> <specializations:MaybeFnSpecializations> => ast::FnDef { name, meta, specializations }
};

GenericDef: ast::GenericDef = {
  <name:Identifier> <ty:(Token<":"> <Type>)?> <init_value:(Token<"="> <Expr>)?> => ast::GenericDef { name, ty, init_value },
};

MaybeFnSpecializations: Vec<ast::FnSpecialization> = {
  <w:FnSpecializationWhere*> <d:FnSpecializationDefault> => {
    let mut w = w;
    w.push(d);
    w
  },
  <body:FnBody> => vec![ast::FnSpecialization { where_expr: None, body }],
};

FnSpecializationWhere: ast::FnSpecialization = {
  Token<"where"> <e:ExprTypeLevel> <body:FnBody> => ast::FnSpecialization { where_expr: Some(e), body },
};

FnSpecializationDefault: ast::FnSpecialization = {
  Token<"default"> <body:FnBody> => ast::FnSpecialization { where_expr: None, body },
};

FnBody: ast::FnBody = {
  Token<"{"> <body:Body> Token<"}"> => ast::FnBody { body },
};

Type: ast::Type = {
  Token<"fn"> <meta:FnMeta> => ast::Type { v: ast::TypeV::Fn { meta } },
  <tyexp:Expr> => ast::Type { v: ast::TypeV::Dynamic {
    tyexp,
  } },
};

FnMeta: ast::FnMeta = {
  <tyargs:FnTyArgList?> <args:FnArgList> <ret:FnRet?> => ast::FnMeta {
    tyargs: tyargs.unwrap_or_else(|| vec![]),
    args,
    ret,
  },
};

FnRet: Box<ast::Type> = {
  Token<"->"> <ty:Type> => Box::new(ty),
};

FnTyArgList: Vec<ast::FnTyArg> = {
  Token<"<"> <list:Comma<FnTyArg>> Token<">"> => list,
};

FnTyArg: ast::FnTyArg = {
  <name:Identifier> Token<":"> <kind:Type> => ast::FnTyArg { name, kind },
};

FnArgList: Vec<ast::FnArg> = {
  Token<"("> <list:Comma<FnArg>> Token<")"> => list,
};

FnArg: ast::FnArg = {
  <name:Identifier> Token<":"> <ty:Type> => ast::FnArg { name, ty },
};

ActualTyArgList: Vec<ast::Expr> = {
  Token<"<"> <list:Comma<ExprTypeLevel>> Token<">"> => list,
};

ActualArgList<I>: Vec<ast::Expr> = {
  Token<"("> <list:Comma<I>> Token<")"> => list,
};

Block: ast::Block = {
  Token<"{"> <args:FnArgList> Token<"in"> <body:Body> Token<"}"> => ast::Block { args, body },
  Token<"{"> <body:Body> Token<"}"> => ast::Block { args: vec![], body },
};

Body: Vec<ast::Stmt> = {
  Stmt*
};

Stmt: ast::Stmt = {
  <v:StmtV> => ast::Stmt { v },
};

StmtV: ast::StmtV = {
  Token<"let"> <def:GenericDef> Token<";"> => ast::StmtV::Let { def },
  Token<"signal"> <def:GenericDef> Token<";"> => ast::StmtV::Signal { def },
  Token<"if"> <e:Expr> Token<"{"> <if_body:Body> Token<"}"> => ast::StmtV::IfElse { condition: e, if_body, else_body: None },
  Token<"if"> <e:Expr> Token<"{"> <if_body:Body> Token<"}"> Token<"else"> Token<"{"> <else_body:Body> Token<"}"> => ast::StmtV::IfElse {
    condition: e,
    if_body,
    else_body: Some(else_body),
  },
  <left:Identifier> "=" <right:Expr> => ast::StmtV::Assign { left, right },
  <e:Expr> ";" => ast::StmtV::Expr { e },
  <e:Expr> <b:Block> ";"? => {
    let mut e = e;
    let b = ast::Expr { v: ast::ExprV::Block(Box::new(b)) };
    if let ast::ExprV::Call { ref mut args, .. } = e.v {
      args.push(b);
      ast::StmtV::Expr { e }
    } else {
      ast::StmtV::Expr {
        e: ast::Expr {
          v: ast::ExprV::Call {
            base: Box::new(e),
            args: vec![b],
          },
        },
      }
    }
  }
}

ExprBase<I>: ast::Expr = {
  <v:ExprBaseV<I>> => ast::Expr { v }
};

ExprBaseV<I>: ast::ExprV = {
  <l:Literal> => ast::ExprV::Lit(l),
  <id:Identifier> => ast::ExprV::Ident(id),
  <base:I> "." <id:Identifier> => ast::ExprV::Dot { base: Box::new(base), id },
  <base:I> <tyargs:ActualTyArgList> => ast::ExprV::Specialize { base: Box::new(base), tyargs },
  <base:I> <args:ActualArgList<I>> => {
    ast::ExprV::Call { base: Box::new(base), args }
  },
  <b:Block> => ast::ExprV::Block(Box::new(b)),
};

ExprTypeLevel: ast::Expr = {
  ExprBase<ExprTypeLevel>,
};

Expr: ast::Expr = {
  ExprBase<Expr>,
};

Literal: ast::Literal = {
  <s:Token<r"[0-9]+">> =>? s.parse().map(|x| ast::Literal { v: ast::LiteralV::Uint(x) }).map_err(|_| ParseError::User {
    error: LocalParseError::InvalidLiteral,
  }),
  <s:Token<r"0x[0-9a-fA-F]+">> =>? helper::parse_radix_prefixed_str(s, "0x", 16),
  <s:Token<r"0o[0-9a-fA-F]+">> =>? helper::parse_radix_prefixed_str(s, "0o", 8),
  <s:Token<r"0b[0-9a-fA-F]+">> =>? helper::parse_radix_prefixed_str(s, "0b", 2),
};

StringLit: String = {
  <s:Token<r#""(\\.|.)*""#>> =>? serde_json::from_str::<String>(s)
    .map_err(|_| ParseError::User {
      error: LocalParseError::InvalidLiteral,
    }),
};

Identifier: ast::Identifier = {
  <s:Token<r"[a-zA-Z_][0-9a-zA-Z_]*">> => ast::Identifier(s.to_string()),
};

Comma<T>: Vec<T> = { 
  <v:(<T> ",")*> <e:T?> => match e {
    None => v,
    Some(e) => {
      let mut v = v;
      v.push(e);
      v
    }
  }
};

Token<I>: I = {
  <s:I> <c:Comment?> => s,
};

Comment: () = {
  r"//[^\n\r]*[\n\r]*" => { },
  r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
};
