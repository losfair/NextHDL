use crate::ast;
use crate::parser::error::LocalParseError;
use lalrpop_util::ParseError;
use crate::parser::grammar_helper as helper;
use crate::parser::state::State;
use std::sync::Arc;
use crate::util::{ArcSliceExt, mk_arc_slice};
use std::collections::BTreeMap;

grammar(state: &mut State);

extern {
  type Error = LocalParseError;
}

pub ModuleDef: ast::ModuleDef = {
  <c:Comment*> <items:ModuleItem*> => ast::ModuleDef { items: mk_arc_slice(items.into_iter()) },
};

ModuleItem: ast::ModuleItem = {
  <x:FnDef> => ast::ModuleItem::Fn(x),
  <x:StructDef> => ast::ModuleItem::Struct(x),
  Token<"extern"> Token<"signal"> <x:GenericDef> Token<";"> => ast::ModuleItem::ExternSignal(x),
  Token<"import"> <path:StringLit> Token<"as"> <as_name:Identifier> Token<";"> => ast::ModuleItem::Import(ast::ImportItem { path, as_name }),
};

StructDef: ast::StructDef = {
  Token<"struct"> <name:Identifier> <tyargs:TyArgList?> Token<"{"> <fields:(<GenericDef> ",")*> <last_field:GenericDef?> Token<"}"> => {
    let fields: BTreeMap<Arc<str>, ast::GenericDef> =
      fields.into_iter().chain(std::iter::once(last_field).filter_map(|x| x))
        .map(|x| (x.name.0.clone(), x))
        .collect();
    ast::StructDef { name, fields: Arc::new(fields), tyargs: tyargs.unwrap_or_else(|| Arc::new([])) }
  },
};

FnDef: ast::FnDef = {
  Token<"fn"> <name:Identifier> <meta:FnMeta> <specializations:MaybeFnSpecializations> => ast::FnDef { name, meta, specializations }
};

GenericDef: ast::GenericDef = {
  <name:Identifier> <ty:(Token<":"> <Type>)?> <init_value:(Token<"="> <Expr>)?> => ast::GenericDef { name, ty, init_value },
};

MaybeFnSpecializations: Arc<[ast::FnSpecialization]> = {
  <w:FnSpecializationWhere*> <d:FnSpecializationDefault> => {
    mk_arc_slice(w.into_iter().chain(std::iter::once(d)))
  },
  <body:FnBody> => mk_arc_slice(std::iter::once(ast::FnSpecialization { where_expr: None, body })),
};

FnSpecializationWhere: ast::FnSpecialization = {
  Token<"where"> <e:ExprTypeLevel> <body:FnBody> => ast::FnSpecialization { where_expr: Some(e), body },
};

FnSpecializationDefault: ast::FnSpecialization = {
  Token<"default"> <body:FnBody> => ast::FnSpecialization { where_expr: None, body },
};

FnBody: ast::FnBody = {
  Token<"{"> <body:Body> Token<"}"> => ast::FnBody { body },
};

Type: ast::Type = {
  Token<"fn"> <meta:FnMeta> => ast::Type { v: ast::TypeV::Fn { meta } },
  <tyexp:Expr> => ast::Type { v: ast::TypeV::Dynamic {
    tyexp,
  } },
};

FnMeta: ast::FnMeta = {
  <tyargs:TyArgList?> <args:FnArgList> <ret:FnRet?> => ast::FnMeta {
    tyargs: tyargs.unwrap_or_else(|| Arc::new([])),
    args,
    ret,
  },
};

FnRet: Arc<ast::Type> = {
  Token<"->"> <ty:Type> => Arc::new(ty),
};

TyArgList: Arc<[ast::TyArg]> = {
  Token<"<"> <list:Comma<TyArg>> Token<">"> => list,
};

TyArg: ast::TyArg = {
  <name:Identifier> Token<":"> <kind:Type> <default_value:(Token<"="> <ExprTypeLevel>)?> => ast::TyArg { name, kind, default_value },
};

FnArgList: Arc<[ast::FnArg]> = {
  Token<"("> <list:Comma<FnArg>> Token<")"> => list,
};

FnArg: ast::FnArg = {
  <name:Identifier> Token<":"> <ty:Type> => ast::FnArg { name, ty },
};

TypeAssignList: Arc<[ast::TypeAssign]> = {
  Token<"<"> <list:Comma<TypeAssign>> Token<">"> => list,
};

TypeAssign: ast::TypeAssign = {
  <e:ExprTypeLevel> => ast::TypeAssign { ty: None, e },
  <ty:Identifier> Token<"="> <e:ExprTypeLevel> => ast::TypeAssign { ty: Some(ty), e },
};

ActualArgList<I>: Arc<[ast::Expr]> = {
  Token<"("> <list:Comma<I>> Token<")"> => list,
};

Block: ast::Block = {
  Token<"{"> <args:FnArgList> Token<"in"> <body:Body> Token<"}"> => ast::Block { args, body },
  Token<"{"> <body:Body> Token<"}"> => ast::Block { args: mk_arc_slice(std::iter::empty()), body },
};

Body: Arc<[ast::Stmt]> = {
  <v:Stmt*> => mk_arc_slice(v.into_iter()),
};

Stmt: ast::Stmt = {
  <v:StmtV> => ast::Stmt { v },
};

StmtV: ast::StmtV = {
  Token<"let"> <def:GenericDef> Token<";"> => ast::StmtV::Let { def },
  Token<"signal"> <def:GenericDef> Token<";"> => ast::StmtV::Signal { def },
  Token<"if"> <e:Expr> Token<"{"> <if_body:Body> Token<"}"> => ast::StmtV::IfElse { condition: e, if_body, else_body: None },
  Token<"if"> <e:Expr> Token<"{"> <if_body:Body> Token<"}"> Token<"else"> Token<"{"> <else_body:Body> Token<"}"> => ast::StmtV::IfElse {
    condition: e,
    if_body,
    else_body: Some(else_body),
  },
  <left:Identifier> Token<"="> <right:Expr> => ast::StmtV::Assign { left, right },
  <e:Expr> Token<";"> => ast::StmtV::Expr { e },
  <mut e:Expr> <b:Block> Token<";">? => {
    let b = ast::Expr { v: ast::ExprV::Block(Arc::new(b)) };
    if let ast::ExprV::Call { ref mut args, .. } = e.v {
      *args = mk_arc_slice(args.take_all().chain(std::iter::once(b)));
      ast::StmtV::Expr { e }
    } else {
      ast::StmtV::Expr {
        e: ast::Expr {
          v: ast::ExprV::Call {
            base: Arc::new(e),
            args: mk_arc_slice(std::iter::once(b)),
          },
        },
      }
    }
  }
}

ExprBase<I>: ast::Expr = {
  <v:ExprBaseV<I>> => ast::Expr { v }
};

ExprBaseV<I>: ast::ExprV = {
  <l:Literal> => ast::ExprV::Lit(l),
  <id:Identifier> => ast::ExprV::Ident(id),
  <base:I> Token<"."> <id:Identifier> => ast::ExprV::Dot { base: Arc::new(base), id },
  <base:I> <tyassigns:TypeAssignList> => ast::ExprV::Specialize { base: Arc::new(base), tyassigns },
  <base:I> <args:ActualArgList<I>> => {
    ast::ExprV::Call { base: Arc::new(base), args }
  },
  <b:Block> => ast::ExprV::Block(Arc::new(b)),
};

ExprTypeLevel: ast::Expr = {
  ExprBase<ExprTypeLevel>,
};

Expr: ast::Expr = {
  ExprBase<Expr>,
};

Literal: ast::Literal = {
  <s:Token<r"[0-9]+">> =>? s.parse().map(|x| ast::Literal { v: ast::LiteralV::Uint(x) }).map_err(|_| ParseError::User {
    error: LocalParseError::InvalidLiteral,
  }),
  <s:Token<r"0x[0-9a-fA-F]+">> =>? helper::parse_radix_prefixed_str(s, "0x", 16),
  <s:Token<r"0o[0-9a-fA-F]+">> =>? helper::parse_radix_prefixed_str(s, "0o", 8),
  <s:Token<r"0b[0-9a-fA-F]+">> =>? helper::parse_radix_prefixed_str(s, "0b", 2),
};

StringLit: Arc<str> = {
  <s:Token<r#""(\\.|.)*""#>> =>? serde_json::from_str::<String>(s)
    .map(|x| state.get_string(&x))
    .map_err(|_| ParseError::User {
      error: LocalParseError::InvalidLiteral,
    }),
};

Identifier: ast::Identifier = {
  <s:Token<r"[a-zA-Z_][0-9a-zA-Z_]*">> => ast::Identifier(state.get_string(s)),
};

Comma<T>: Arc<[T]> = { 
  <v:(<T> Token<",">)*> <e:T?> => match e {
    None => mk_arc_slice(v.into_iter()),
    Some(e) => mk_arc_slice(v.into_iter().chain(std::iter::once(e))),
  }
};

Token<I>: I = {
  <s:I> <c:Comment*> => s,
};

Comment: () = {
  r"//[^\n\r]*[\n\r]*" => { },
  r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
};
